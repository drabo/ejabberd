---
# Source: ejabberd/templates/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: ejabberd
---
# Source: ejabberd/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: ejabberd-yml
  namespace: ejabberd
type: Opaque
stringData:
  ejabberd.yml: |-
    ###
    ###'           ejabberd configuration file
    ###
    ### The parameters used in this configuration file are explained at
    ###
    ###       https://docs.ejabberd.im/admin/configuration
    ###
    ### The configuration file is written in YAML.
    ### *******************************************************
    ### *******           !!! WARNING !!!               *******
    ### *******     YAML IS INDENTATION SENSITIVE       *******
    ### ******* MAKE SURE YOU INDENT SECTIONS CORRECTLY *******
    ### *******************************************************
    ### Refer to http://en.wikipedia.org/wiki/YAML for the brief description.
    ###
    
    hosts:
      - "ejabberd.example.com"
    
    new_sql_schema: true
    
    host_config:
      "ejabberd.example.com":
        sql_type: mysql
        sql_server: "ejabberd-db.example.com"
        sql_database: "ejabberd"
        sql_username: "ejabberd"
        sql_password: "ejabberd"
        sql_port: 3306
        sql_keepalive_interval: 600
        auth_method:
          - sql
        allow_multiple_connections: false
    
    default_db: sql
    
    loglevel: 5
    log_rotate_size: 10485760
    log_rotate_date: ""
    log_rotate_count: 10
    log_rate_limit: 100
    
    listen:
      -
        port: 5222
        module: ejabberd_c2s
        max_stanza_size: 262144
        shaper: c2s_shaper
        access: c2s
      # starttls_required: true
      -
        port: 5269
        module: ejabberd_s2s_in
        max_stanza_size: 524288
      # -
      #   port: 5443
      #   module: ejabberd_http
      #   tls: true
      #   request_handlers:
      #     "/admin": ejabberd_web_admin
      #     "/api": mod_http_api
      #     "/bosh": mod_bosh
      #     "/captcha": ejabberd_captcha
      #     "/upload": mod_http_upload
      #     "/ws": ejabberd_http_ws
      #     "/oauth": ejabberd_oauth
      -
        port: 5280
        module: ejabberd_http
        request_handlers:
          "/admin": ejabberd_web_admin
          "/api": mod_http_api
          "/bosh": mod_bosh
    #      "/captcha": ejabberd_captcha
          "/upload": mod_http_upload
          "/ws": ejabberd_http_ws
    #      "/oauth": ejabberd_oauth
        web_admin: true
        http_bind: true
        http_poll: true	
        register: false
        captcha: true
    
      -
        port: 1883
        module: mod_mqtt
        backlog: 1000
    
    s2s_use_starttls: optional
    
    acl:
      local:
        user_regexp: ""
      loopback:
        ip:
          - 127.0.0.0/8
      admin:
        user:
          - "admin@ejabberd.example.com"
          - "system@ejabberd.example.com"
    
    access_rules:
      local:
        allow: local
      c2s:
        deny: blocked
        allow: all
      announce:
        allow: admin
      configure:
        allow: admin
      muc_create:
        allow: local
      pubsub_createnode:
        allow: local
      trusted_network:
        allow: loopback
    
    api_permissions:
      "console commands":
        from:
          - ejabberd_ctl
        who: all
        what: "*"
      "admin access":
        who:
          access:
            allow:
              - all
    #          acl: loopback
    #          acl: admin
          oauth:
            scope: "ejabberd:admin"
            access:
              allow:
                - acl: loopback
                - acl: admin
        what:
          - "*"
          - "!stop"
          - "!start"
      "public commands":
        who:
          ip: 10.0.0.0/16
        what:
          - status
          - connected_users_number
    
    shaper:
      normal: 1000
      fast: 50000
    
    shaper_rules:
      max_user_sessions: 10
      max_user_offline_messages:
        5000: admin
        100: all
      c2s_shaper:
        none: admin
        normal: all
      s2s_shaper: fast
    
    max_fsm_queue: 10000
    
    # acme:
    #   contact: "mailto:admin@danviha"
    #   ca_url: "https://acme-v01.api.letsencrypt.org"
    
    modules:
      mod_admin_update_sql: {}
      mod_adhoc: {}
      mod_admin_extra: {}
      mod_announce:
        access: announce
      mod_avatar: {}
      mod_blocking: {}
      mod_bosh: {}
      mod_caps: {}
      mod_carboncopy: {}
      mod_client_state: 
    # Queue “standalone” chat state notifications (as defined in XEP-0085) while a client indicates inactivity. The default value is true.
        queue_chat_states: true 
    # Queue PEP notifications while a client is inactive. When the queue is flushed, only the most recent notification of a given PEP node is delivered. The default value is true.
        queue_pep: true 
    # While a client is inactive, queue presence stanzas that indicate (un)availability. The default value is true.
        queue_presence: true 
      mod_configure: {}
    #  mod_disco: {}
      mod_fail2ban: {}
      mod_http_api: {}
      mod_http_upload:
        put_url: https://www.example.com/ejabberd/upload
        docroot: /home/ejabberd/upload
        custom_headers:
          "Access-Control-Allow-Origin": "*"
          "Access-Control-Allow-Methods": "OPTIONS, HEAD, GET, PUT"
          "Access-Control-Allow-Headers": "Content-Type"
      mod_last: {}
      mod_mam:
        ## Mnesia is limited to 2GB, better to use an SQL backend
        ## For small servers SQLite is a good fit and is very easy
        ## to configure. Uncomment this when you have SQL configured:
        db_type: sql
        assume_mam_usage: true
    #default: always|never|roster    
        default: always  
      mod_mqtt: {}
      mod_muc:
        access:
          - allow
        access_admin:
          - allow: admin
        access_create: muc_create
        access_persistent: muc_create
        access_mam:
          - allow
        db_type: sql
        max_user_conferences: 10000
        default_room_options:
          mam: true
          public: false
          public_list: false
          allow_change_subj: false
          allow_user_invites: false
          members_only: false
          members_by_default: false
          anonymous: false
          allow_private_messages: false
          persistent: true
        preload_rooms: false
      mod_muc_admin: {}
      mod_offline:
        db_type: sql
        access_max_user_messages: max_user_offline_messages
        use_mam_for_storage: true
      mod_ping:
        send_pings: true
        ping_interval: 30
        timeout_action: none
      mod_privacy: {}
      mod_private: {}
      mod_proxy65:
        access: local
        max_connections: 100
      mod_pubsub:
        access_createnode: pubsub_createnode
        plugins:
          - flat
          - pep
        force_node_config:
          ## Avoid buggy clients to make their bookmarks public
          storage:bookmarks:
            access_model: whitelist
      mod_push: {}
      mod_push_keepalive: {}
      mod_register:
        ## Only accept registration requests from the "trusted"
        ## network (see access_rules section above).
        ## Think twice before enabling registration from any
        ## address. See the Jabber SPAM Manifesto for details:
        ## https://github.com/ge0rg/jabber-spam-fighting-manifesto
        ip_access: trusted_network
      mod_roster:
        db_type: sql
        versioning: true
      mod_s2s_dialback: {}
      mod_shared_roster: {}
      mod_stream_mgmt:
        resend_on_timeout: if_offline
      mod_vcard: {}
      mod_vcard_xupdate: {}
      mod_version:
        show_os: false
    
    ### Local Variables:
    ### mode: yaml
    ### End:
    ### vim: set filetype=yaml tabstop=8
---
# Source: ejabberd/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: erlang-cookie
  namespace: ejabberd
type: Opaque
stringData:
  .erlang.cookie: |-
    thahGhi7ineighoocoom
---
# Source: ejabberd/templates/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cluster-startup
  namespace: ejabberd
data:
  cluster.sh: |-
    #!/usr/bin/env sh
    set -x
    
    apk update && apk add --no-cache curl && rm -rf /var/cache/apk/*
    
    EJABBERDCTL=$HOME/bin/ejabberdctl
    HOSTNAME_S=$(hostname -s) # ejabberd-0
    HOSTNAME_F=$(hostname -f) # ejabberd-0.ejabberd.default.svc.cluster.local
    HEADLESS_SERVICE="${HOSTNAME_F/$HOSTNAME_S./}" # ejabberd.default.svc.cluster.local
    ERLANG_NODE_ARG="ejabberd@$HOSTNAME_F" # ejabberd@ejabberd-0.ejabberd.default.svc.cluster.local
    ERLANG_NODE=$ERLANG_NODE_ARG
    
    echo $HOME
    echo $EJABBERDCTL
    echo $HEADLESS_SERVICE
    echo $ERLANG_NODE_ARG
    
    # rm -f /home/ejabberd/database/$ERLANG_NODE_ARG/MnesiaCore.$ERLANG_NODE_ARG* 2>/dev/null
    
    IPS=$(nslookup $HEADLESS_SERVICE | tail -n +3 | grep "Address:" | sed -E 's/^Address: (.*)$/\1/')
    for IP in ${IPS}
    do
        echo "looking up hostname for: $IP"
        HOSTNAME=$(nslookup $IP | tail -n +3 | grep -E '[^=]*= (.*).'"$HEADLESS_SERVICE"'$'  | sed -E 's/[^=]*= (.*).'"$HEADLESS_SERVICE"'$/\1/')
        if [ "$HOSTNAME_S" == "$HOSTNAME" ] ; then
            echo "found own hostname, skipping"
            continue
        fi
        $EJABBERDCTL --node $ERLANG_NODE_ARG start
        $EJABBERDCTL --node $ERLANG_NODE_ARG started
        $EJABBERDCTL --node $ERLANG_NODE_ARG status
        echo "trying to connect to node with hostname $HOSTNAME.$HEADLESS_SERVICE"
        $EJABBERDCTL --node $ERLANG_NODE_ARG --no-timeout join_cluster "ejabberd@$HOSTNAME.$HEADLESS_SERVICE"
        CLUSTERING_RESULT=$?
        $EJABBERDCTL --node $ERLANG_NODE_ARG list_cluster
        $EJABBERDCTL --node $ERLANG_NODE_ARG stop
        $EJABBERDCTL --node $ERLANG_NODE_ARG stopped
        if [ $? -eq 0 ] ; then
            echo "successfully joined";
            break
        else
            echo "failed to join, trying next";
        fi
    done
    
    #Define cleanup procedure
    cleanup() {
        echo "Container stopped, performing cleanup..."
        $EJABBERDCTL --node $ERLANG_NODE_ARG leave_cluster "$ERLANG_NODE_ARG"
        $EJABBERDCTL --node $ERLANG_NODE_ARG stop
    }
    
    #Trap SIGTERM
    trap 'cleanup' SIGTERM
    
    echo "launching in foreground"
    $EJABBERDCTL --node $ERLANG_NODE_ARG foreground &
    
    #Wait
    wait $!
---
# Source: ejabberd/templates/pvc-nfs.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ejabberd-uploads-efs
  namespace: ejabberd
spec:
  accessModes:
  - ReadWriteMany
  storageClassName: "efs"
  resources:
    requests:
      storage: "1Mi"
---
# Source: ejabberd/templates/service-nlb.yaml
apiVersion: v1
kind: Service
metadata:
  name: ejabberd-nlb
  namespace: ejabberd
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-additional-resource-tags: Name=dev-ejabberd-nlb,Environment=dev,ManagedBy=me@example.com
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: tcp
    service.beta.kubernetes.io/aws-load-balancer-internal: 0.0.0.0/0
    service.beta.kubernetes.io/aws-load-balancer-name: dev-ejabberd-nlb
    service.beta.kubernetes.io/aws-load-balancer-proxy-protocol: '*'
    service.beta.kubernetes.io/aws-load-balancer-type: nlb
    service.beta.kubernetes.io/aws-load-balancer-subnets: dev-k8s-nlb-a, dev-k8s-nlb-b, dev-k8s-nlb-c
    service.beta.kubernetes.io/aws-load-balancer-target-group-attributes: stickiness.enabled=true,stickiness.type=source_ip
spec:
  type: LoadBalancer
  healthCheckNodePort: 30436
  externalTrafficPolicy: Local
  selector:
    app: ejabberd
  ports:
  - name: bosh
    protocol: TCP
    port: 5280
    targetPort: 5280
  - name: xmpp
    protocol: TCP
    port: 5222
    targetPort: 5222
---
# Source: ejabberd/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: ejabberd-http-svc
  namespace: ejabberd
spec:
  selector:
    app: ejabberd
  ports:
  - name: http
    protocol: TCP
    port: 80
    targetPort: 5280
---
# Source: ejabberd/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: ejabberd-headless
  namespace: ejabberd
spec:
  selector:
    app: ejabberd
  clusterIP: None
  clusterIPs:
  - None
  ports:
  - name: cluster
    protocol: TCP
    port: 4369
    targetPort: 4369
  publishNotReadyAddresses: true
  sessionAffinity: None
  type: ClusterIP
---
# Source: ejabberd/templates/statefulset-cluster.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: ejabberd
  namespace: ejabberd
spec:
  replicas: 3
  selector:
    matchLabels:
     app: ejabberd
  serviceName: ejabberd-headless
  volumeClaimTemplates:
  - metadata:
      name: ejabberd-db
      labels:
        app: ejabberd
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
  - metadata:
      name: ejabberd-logs
      labels:
        app: ejabberd
    spec:
      accessModes: [ "ReadWriteOnce" ]
      resources:
        requests:
          storage: 1Gi
  template:
    metadata:
      labels:
        app: ejabberd
      annotations:
        co.elastic.logs/multiline.match: after
        co.elastic.logs/multiline.negate: "true"
        co.elastic.logs/multiline.pattern: ^[0-9]{4}-[0-9]{2}-[0-9]{2}
        prometheus.io/path: /actuator/prometheus
        prometheus.io/port: "9000"
        prometheus.io/scrape: "true"
    spec:
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - podAffinityTerm:
              labelSelector:
                matchExpressions:
                - key: app
                  operator: In
                  values:
                  - ejabberd
              topologyKey: kubernetes.io/hostname
            weight: 1
      initContainers:
      - name: cookie-startup
        image: busybox
        imagePullPolicy: IfNotPresent
        command:
          - sh
          - -c
          - mkdir -p /cookie && cp /tmp/.erlang.cookie /cookie/ && chmod 0400 /cookie/.erlang.cookie && chown 9000:9000 /cookie/.erlang.cookie
        volumeMounts:
        - name: erlang-cookie
          mountPath: /tmp/.erlang.cookie
          subPath: .erlang.cookie
        - name: cookie-volume
          mountPath: /cookie
      - name: cluster-db-cleanup
        image: busybox
        imagePullPolicy: IfNotPresent
        command:
          - sh
          - -c
          - rm -rf /home/ejabberd/database/*
        volumeMounts:
        - name: ejabberd-db
          mountPath: /home/ejabberd/database
          subPath: database
      - name: cluster-startup
        image: busybox
        imagePullPolicy: IfNotPresent
        command:
          - sh
          - -c
          - mkdir -p /cluster/bin && cp /tmp/cluster.sh /cluster/bin/ && chmod +x /cluster/bin/cluster.sh
        volumeMounts:
        - name: config-map
          mountPath: /tmp/cluster.sh
          subPath: cluster.sh
        - name: cluster-volume
          mountPath: /cluster/bin
      containers:
      - name: ejabberd
        image: ejabberd/ecs:22.05
        imagePullPolicy: Always
        command:
        - "/usr/local/bin/cluster.sh"
        env:
        - name: TZ
          value: Europe/Bucharest
        ports:
        - name: http
          protocol: TCP
          containerPort: 5280
        - name: xmpp
          protocol: TCP
          containerPort: 5222
        - name: cluster
          protocol: TCP
          containerPort: 4369
        readinessProbe:
          httpGet:
            path: /api/status
            port: 5280
          initialDelaySeconds: 30
          timeoutSeconds: 10
        resources:
          limits:
            cpu: "1"
          requests:
            cpu: 100m
        volumeMounts:
        - name: ejabberd-shared
          mountPath: /home/ejabberd/upload
        - name: ejabberd-yml
          mountPath: /home/ejabberd/conf/ejabberd.yml
          subPath: ejabberd.yml
          readOnly: true
        - name: cluster-volume
          mountPath: /usr/local/bin/cluster.sh
          subPath: cluster.sh
          readOnly: true
        - name: cookie-volume
          mountPath: /home/ejabberd/.erlang.cookie
          subPath: .erlang.cookie
          readOnly: true
        - name: ejabberd-db
          mountPath: /home/ejabberd/database
          subPath: database
        - name: ejabberd-logs
          mountPath: /home/ejabberd/logs
          subPath: logs
        securityContext:
          allowPrivilegeEscalation: true
          runAsUser: 0
      volumes:
      - name: ejabberd-shared
        persistentVolumeClaim:
          claimName: ejabberd-uploads-efs
      - name: ejabberd-yml
        secret:
          secretName: ejabberd-yml
          defaultMode: 
      - name: cluster-volume
        emptyDir: {}
      - name: config-map
        configMap:
          name: cluster-startup
          items:
          - key: cluster.sh
            path: cluster.sh
      - name: cookie-volume
        emptyDir: {}
      - name: erlang-cookie
        secret:
          secretName: erlang-cookie
          defaultMode: 
      securityContext:
        fsGroup: 9000
---
# Source: ejabberd/templates/istio.yaml
apiVersion: networking.istio.io/v1beta1
kind: Gateway
metadata:
  name: ejabberd-http-gw
  namespace: ejabberd
spec:
  selector:
    istio: ingressgateway
  servers:
  - port:
      number: 80
      name: http
      protocol: HTTP
    hosts:
    - ejabberd-gui.example.com
---
# Source: ejabberd/templates/istio.yaml
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: ejabberd-http-vs
  namespace: ejabberd
spec:
  hosts:
  - ejabberd-gui.example.com
  gateways:
  - ejabberd-http-gw
  http:
  - route:
    - destination:
        host: ejabberd-http-svc.ejabberd.svc.cluster.local
        port:
          number: 80
      weight: 100
